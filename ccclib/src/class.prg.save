
/*
 *  CCC - The Clipper to C++ Compiler
 *  Copyright (C) 2005 ComFirm BT.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

//Ebbe a modulba kell tenni azokat a függvényeket,
//amiknek közvetlenül aclass-on kell dolgozni.
//Egyik függvénynek sem lehet olyan visszatérési értéke,
//amin keresztül aclass véletlenül módosítható.

static aclass:={}

static mutex:=thread_mutex_init()
#define MUTEX_LOCK    (signal_lock(),thread_mutex_lock(mutex))
#define MUTEX_UNLOCK  (thread_mutex_unlock(mutex),signal_unlock())
//#define MUTEX_LOCK      thread_mutex_lock(mutex)
//#define MUTEX_UNLOCK    thread_mutex_unlock(mutex)

//Az aclass array-hez való hozzáférést mutex szinkronizálja.
//Ha azonban szignál jön a MUTEX_LOCK és MUTEX_UNLOCK között,
//és a szignál kezelő maga is lockolni akarja a mutexet, akkor 
//deadlock keletkezhet. Ezt akadályozza meg signal_lock(),
//ami a kurrens szálat védi a szignáloktól. 

#define  CLASS_NAME      1    //osztálynév
#define  CLASS_BASEID    2    //baseclass azonosító array
#define  CLASS_ATTRCNT   3    //attribútumok száma (objektumok hossza)
#define  CLASS_SLOTCNT   4    //attribútumok+metódusok száma
#define  CLASS_HASHTAB   5    //hash tábla

//Ha a hash tábla MAXFILL-nél jobban megtelik,
//akkor a méretét INCREMENT szerint növeljük.
//A 0.66 és 2 szorzókkal az átméretezett táblák 
//kitöltöttsége 1/3 és 2/3 között lesz.

#define  HASHTAB_INITSIZE        64
#define  HASHTAB_INCREMENT(x)    len(x)*2
#define  HASHTAB_MAXFILL(x)      len(x)*0.66


******************************************************************************
static function hash_rebuild(hash,len)
local hash1:=array(len),n,x
    for n:=1 to len(hash)
        if( hash[n]!=NIL )
            x:=hash_index(hash1,hash[n][1])
            hash1[x]:=hash[n]
        end
    next
    return hash1

// A hash tábla egy array: {item1,item2,...},
// ahol item==NIL, vagy item=={key,...} alakú.

******************************************************************************
static function hash_index(hash,key,hcode)

local hlen:=len(hash)
local hidx:=if(hcode==NIL,hashcode(key),hcode)%hlen

    while( .t. )
        if( NIL==hash[1+hidx] )
            return 1+hidx
        elseif( key==hash[1+hidx][1] )
            return 1+hidx
        elseif( ++hidx>=hlen )
            hidx:=0
        end
    end
    return NIL


// Keresés a hash táblában:
//    
// A ciklus véget ér, ui. a tábla hosszabb, 
// mint ahány nem NIL elem van benne.    
//
// visszatérés: hashidx
//
// Ha hash[hasidx]==NIL, akkor a keresett elem nincs a táblában,
//                       és éppen a hashidx helyre kell/lehet betenni.
//
// Ha hash[hasidx]!=NIL, akkor az a keresett elem.


******************************************************************************
static function getclsdef(clid)
local clsdef
    MUTEX_LOCK
    clsdef:=aclass[clid]
    MUTEX_UNLOCK
    return clsdef

******************************************************************************
function classListAll()
local n,clsdef,clscount

    MUTEX_LOCK
    clscount:=len(aclass)
    MUTEX_UNLOCK

    for n:=1 to clscount
        clsdef:=getclsdef(n)
        ? str(n,4),;                         // clid
          padr(clsdef[CLASS_NAME],64),;      // classname
          str(clsdef[CLASS_ATTRCNT],4),;     // attrcount
          str(clsdef[CLASS_SLOTCNT],4),;     // slotcount (attr+meth)
          str(len(clsdef[CLASS_HASHTAB]),4)  // hashtab size
    next
    ?
    return NIL

******************************************************************************
function classRegister(clname,clbaseid)

// clbaseid lehet
//
// NIL   : nincs felmenő osztály (gyökér)
// szám  : baseclass (egyszeres öröklődés)
// array : baseclass-ok listája (többszörös örölődés)

local aid,i,s
local hash:=array(HASHTAB_INITSIZE),bhash
local name,value,inherit
local olen:=0,slen:=0
local hashidx
local clid

    if( clbaseid==NIL )
        aid:={}
    elseif( valtype(clbaseid)=="N" )
        aid:={clbaseid}
    else
        aid:=clbaseid
    end

    for i:=1 to len(aid) //végigmegy a baseclass-okon
    
        bhash:=getclsdef(aid[i])[CLASS_HASHTAB]
        
        for s:=1 to len(bhash) //végigmegy a baseclass slotjain
        
            if( bhash[s]!=NIL )

                name:=bhash[s][1]
                value:=bhash[s][2] 
                inherit:=bhash[s][3] 

                hashidx:=hash_index(hash,name)
            
                if( hash[hashidx]==NIL ) 
                    //nincs még ilyen

                    if( valtype(value)=="B" )
                        hash[hashidx]:={name,value,inherit}  //új array!
                    else
                        hash[hashidx]:={name,++olen,inherit}
                    end

                    if( ++slen>HASHTAB_MAXFILL(hash) )
                        hash:=hash_rebuild(hash,HASHTAB_INCREMENT(hash) )
                    end
                end
            end
        next
    next

    MUTEX_LOCK
    aadd(aclass,{str2bin(lower(clname)),aid,olen,slen,hash}) 
    clid:=len(aclass) //classid
    MUTEX_UNLOCK    

    return clid 


******************************************************************************
function classAttrib(clid,name)

local clsdef:=getclsdef(clid)
local lname:=str2bin(lower(name))
local hash:=clsdef[CLASS_HASHTAB]
local hashidx:=hash_index(hash,lname)

    if( hash[hashidx]==NIL ) //új attribútum

        hash[hashidx]:={lname,++clsdef[CLASS_ATTRCNT],clid}

        if( ++clsdef[CLASS_SLOTCNT] > HASHTAB_MAXFILL(hash) )
            clsdef[CLASS_HASHTAB]:=hash_rebuild(hash,HASHTAB_INCREMENT(hash))
        end

    else //felüldefiniálás
 
        //method -> attrib : kódblokk helyére index, ++hossz
        //attrib -> attrib : OK

        if( valtype(hash[hashidx][2])=="B" )
            hash[hashidx][2]:=++clsdef[CLASS_ATTRCNT]
            hash[hashidx][3]:=clid 
        end
    end
    
    return NIL


******************************************************************************
function classMethod(clid,name,methblk)

local clsdef:=getclsdef(clid)
local lname:=str2bin(lower(name))
local hash:=clsdef[CLASS_HASHTAB]
local hashidx:=hash_index(hash,lname)

    if( hash[hashidx]==NIL ) //új method

        hash[hashidx]:={lname,methblk,clid}

        if( ++clsdef[CLASS_SLOTCNT] > HASHTAB_MAXFILL(hash) )
            clsdef[CLASS_HASHTAB]:=hash_rebuild(hash,HASHTAB_INCREMENT(hash))
        end

    else //felüldefiniálás
 
        //method -> method : kódblokk csere
        //attrib -> method : index helyére kódblokk (tárolóhely elvész)

        hash[hashidx][2]:=methblk
        hash[hashidx][3]:=clid
    end
    
    return NIL
    

******************************************************************************
function classIdByName(name)
local clid
    name:=str2bin(lower(name))
    MUTEX_LOCK
    clid:=ascan(aclass,{|c|c[CLASS_NAME]==name}) 
    MUTEX_UNLOCK
    return clid
 

******************************************************************************
function classObjectLength(clid)
    return getclsdef(clid)[CLASS_ATTRCNT]


******************************************************************************
function className(clid) 
    return bin2str(getclsdef(clid)[CLASS_NAME])


******************************************************************************
function classBaseID(clid) 
    return aclone(getclsdef(clid)[CLASS_BASEID])


******************************************************************************
function classAttrNames(clid) 
local hash:=getclsdef(clid)[CLASS_HASHTAB],n,attr:={}
    for n:=1 to len(hash)
        if( hash[n]!=NIL .and. valtype(hash[n][2])=="N" ) 
            aadd(attr,hash[n])
        end
    next
    asort(attr,,,{|x,y|x[2]<y[2]}) //index szerint!
    for n:=1 to len(attr)
        attr[n]:=bin2str(attr[n][1])
    next
    return attr


******************************************************************************
function classMethNames(clid) 
local hash:=getclsdef(clid)[CLASS_HASHTAB],n,meth:={}
    for n:=1 to len(hash)
        if( hash[n]!=NIL .and. valtype(hash[n][2])=="B" ) 
            aadd(meth,hash[n][1])
        end
    next
    asort(meth,,,{|x,y|x<y}) //név szerint
    for n:=1 to len(meth)
        meth[n]:=bin2str(meth[n])
    next
    return meth


******************************************************************************
function classInheritStruct(clid) 
local hash:=getclsdef(clid)[CLASS_HASHTAB],n,inherit:={}
    for n:=1 to len(hash)
        if( hash[n]!=NIL )
            aadd(inherit,{bin2str(hash[n][1]),if(valtype(hash[n][2])=="B","M","A"),hash[n][3]} )
        end
    next
    //asort(inherit,,,{|x,y|x[1]<y[1]}) //név szerint
    asort(inherit,,,{|x,y|x[3]<y[3].or.x[3]==y[3].and.x[1]<y[1]}) //clid+név szerint
    return inherit


******************************************************************************
function __findslot(clid,slotname,hashcode)

local hash:=getclsdef(clid)[CLASS_HASHTAB]
local hashidx:=hash_index(hash,slotname,hashcode)
local item:=hash[hashidx], err

    if( item==NIL )
        err:=errorNew()
        err:description:=@"no exported method"
        err:operation:=className(clid)+":"+bin2str(slotname)
        break(err)
    end

    return item[2]  //methblk/attridx


******************************************************************************
function __findslot_c(clid,slotname,classname,hashcode)
local clid1, err
    if( 0==(clid1:=classIDByName(classname)) )
        err:=errorNew()
        err:description:="'"+bin2str(classname)+"' "+@"not a valid classname"
        err:operation:=className(clid)+":("+bin2str(classname)+")"+bin2str(slotname)
        break(err)
    end
    return __findslot(clid1,slotname,hashcode)

 
******************************************************************************
function __findslot_s(clid,slotname,classname,hashcode)

local clid1,baseid,i
local hash,hashidx,err
 
    if( 0==(clid1:=classIDByName(classname)) )
        err:=errorNew()
        err:description:="'"+bin2str(classname)+"' "+@"not a valid classname"
        err:operation:=className(clid)+":(super@"+bin2str(classname)+")"+bin2str(slotname)
        break(err)
    end
    
    baseid:=getclsdef(clid1)[CLASS_BASEID] 
 
    for i:=1 to len(baseid)
        hash:=getclsdef(baseid[i])[CLASS_HASHTAB]
        hashidx:=hash_index(hash,slotname,hashcode)
        if( hash[hashidx]!=NIL )
            return hash[hashidx][2] //methblk/attridx
        end
    next

    err:=errorNew()
    err:description:=@"no exported method"
    err:operation:=className(clid)+":(super@"+bin2str(classname)+")"+bin2str(slotname)
    break(err)
 
    return NIL //nem található  
 

******************************************************************************
function __findslot_p(clid,slotname,prntname,classname,hashcode)

local clid0,clid1,err
 
    if( 0==(clid0:=classIDByName(classname)) )
        err:=errorNew()
        err:description:="'"+bin2str(classname)+"' "+@"not a valid classname"
        err:operation:=className(clid)+":("+bin2str(prntname)+"@"+bin2str(classname)+")"+bin2str(slotname)
        break(err)
    end

    if( 0==(clid1:=classIDByName(prntname)) )
        err:=errorNew()
        err:description:="'"+bin2str(prntname)+"' "+@"not a valid classname"
        err:operation:=className(clid)+":("+bin2str(prntname)+"@"+bin2str(classname)+")"+bin2str(slotname)
        break(err)
    end
    
    if( 0==ascan(getclsdef(clid0)[CLASS_BASEID],clid1)  )
        err:=errorNew()
        err:description:="'"+bin2str(prntname)+"' "+@"is not parent of"+" '"+bin2str(classname)+"'"
        err:operation:=className(clid)+":("+bin2str(prntname)+"@"+bin2str(classname)+")"+bin2str(slotname)
        break(err)
    end

    return __findslot(clid1,slotname,hashcode)
 

******************************************************************************
function getmethod(clid,name) //nem objektumfüggvény
    return __findslot(clid,str2bin(lower(name)))


******************************************************************************

    