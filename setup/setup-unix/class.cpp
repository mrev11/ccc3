//input: ppo/class.ppo (5.7.0.1)

#include <cccdef.h>

static void _blk_classidbyname_0(int argno);
static void _blk_classinheritstruct_0(int argno);
extern void _clp___findslot(int argno);
extern void _clp___findslot3_c(int argno);
extern void _clp___findslot3_p(int argno);
extern void _clp___findslot3_s(int argno);
extern void _clp___findslot_c(int argno);
extern void _clp___findslot_p(int argno);
extern void _clp___findslot_s(int argno);
extern void _clp_aadd(int argno);
extern void _clp_aclone(int argno);
extern void _clp_array(int argno);
extern void _clp_ascan(int argno);
extern void _clp_asize(int argno);
extern void _clp_asort(int argno);
extern void _clp_bin2str(int argno);
extern void _clp_break(int argno);
extern void _clp_classattrib(int argno);
extern void _clp_classattrnames(int argno);
extern void _clp_classbaseid(int argno);
extern void _clp_classidbyname(int argno);
extern void _clp_classinheritstruct(int argno);
extern void _clp_classlistall(int argno);
extern void _clp_classmethnames(int argno);
extern void _clp_classmethod(int argno);
extern void _clp_classmethodcount(int argno);
extern void _clp_classname(int argno);
extern void _clp_classobjectlength(int argno);
extern void _clp_classregister(int argno);
extern void _clp_empty(int argno);
extern void _clp_errornew(int argno);
static void _clp_getclsdef(int argno);
extern void _clp_getmethod(int argno);
static void _clp_hash_index(int argno);
static void _clp_hash_rebuild(int argno);
extern void _clp_hashcode(int argno);
static void _clp_isderivedfrom(int argno);
extern void _clp_len(int argno);
extern void _clp_lower(int argno);
extern void _clp_padr(int argno);
extern void _clp_qout(int argno);
extern void _clp_signal_lock(int argno);
extern void _clp_signal_unlock(int argno);
extern void _clp_str(int argno);
extern void _clp_str2bin(int argno);
extern void _clp_thread_mutex_init(int argno);
extern void _clp_thread_mutex_lock(int argno);
extern void _clp_thread_mutex_unlock(int argno);
extern void _clp_valtype(int argno);

class _method6_description: public _method6_{public: _method6_description():_method6_("description"){};}; static _method6_description _o_method_description;
class _method6_operation: public _method6_{public: _method6_operation():_method6_("operation"){};}; static _method6_operation _o_method_operation;

static VALUE* _st_aclass_ptr()
{
    static stvar _st_aclass;
    static int _ini_aclass=[=](){
        array(0);
        assign(_st_aclass.ptr);
        pop();
        return 1;
    }();
    return _st_aclass.ptr;
}
static VALUE* _st_mutex_ptr()
{
    static stvar _st_mutex;
    static int _ini_mutex=[=](){
        _clp_thread_mutex_init(0);
        assign(_st_mutex.ptr);
        pop();
        return 1;
    }();
    return _st_mutex.ptr;
}
//=======================================================================
static void _clp_hash_rebuild(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+5)PUSHNIL();
argno=2;
push_call("hash_rebuild",base);
//
    line(58);
    push_symbol(base+1);//len
    _clp_array(1);
    assign(base+2);//hash1
    pop();
    line(64);
    {
    line(59);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+3);//n
    lab_1_0:
    push_symbol(base+0);//hash
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_1_2;
        line(63);
        line(60);
        push_symbol(base+0);//hash
        push_symbol(base+3);//n
        idxr();
        push(&NIL);
        neeq();
        cmp_113:;
        if(!flag()) goto if_2_1;
            line(61);
            push_symbol(base+2);//hash1
            push_symbol(base+0);//hash
            push_symbol(base+3);//n
            idxr();
            idxr0(1);
            _clp_hash_index(2);
            assign(base+4);//x
            pop();
            line(62);
            push_symbol(base+0);//hash
            push_symbol(base+3);//n
            idxr();
            push_symbol(base+2);//hash1
            push_symbol(base+4);//x
            assign2(idxxl());
            pop();
        if_2_1:
        if_2_0:;
    lab_1_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+3);//n
    add();
    assign(base+3);//n
    goto lab_1_0;
    lab_1_2:;
    }
    line(65);
    push_symbol(base+2);//hash1
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
static void _clp_hash_index(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,3);
while(stack<base+5)PUSHNIL();
argno=3;
push_call("hash_index",base);
//
    line(73);
    push_symbol(base+0);//hash
    _clp_len(1);
    assign(base+3);//hlen
    pop();
    line(74);
    push_symbol(base+2);//hcode
    push(&NIL);
    eqeq();
    cmp_249:;
    if(flag()){
    push_symbol(base+1);//key
    _clp_hashcode(1);
    }else{
    push_symbol(base+2);//hcode
    }
    push_symbol(base+3);//hlen
    modulo();
    assign(base+4);//hidx
    pop();
    line(84);
    lab_3_1:
    line(76);
    push(&TRUE);
    if(!flag()) goto lab_3_2;
        line(83);
        line(77);
        push(&NIL);
        push_symbol(base+0);//hash
        push_symbol(base+4);//hidx
        addnum(1);
        idxr();
        eqeq();
        cmp_294:;
        if(!flag()) goto if_4_1;
            line(78);
            push_symbol(base+4);//hidx
            addnum(1);
            {*base=*(stack-1);stack=base+1;pop_call();return;}
        goto if_4_0;
        if_4_1:
        line(79);
        push_symbol(base+1);//key
        push_symbol(base+0);//hash
        push_symbol(base+4);//hidx
        addnum(1);
        idxr();
        idxr0(1);
        eqeq();
        cmp_330:;
        if(!flag()) goto if_4_2;
            line(80);
            push_symbol(base+4);//hidx
            addnum(1);
            {*base=*(stack-1);stack=base+1;pop_call();return;}
        goto if_4_0;
        if_4_2:
        line(81);
        push_symbol(base+4);//hidx
        push(&ONE);
        add();
        assign(base+4);//hidx
        push_symbol(base+3);//hlen
        gteq();
        cmp_373:;
        if(!flag()) goto if_4_3;
            line(82);
            push(&ZERO);
            assign(base+4);//hidx
            pop();
        if_4_3:
        if_4_0:;
    goto lab_3_1;
    lab_3_2:;
    line(85);
    push(&NIL);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
static void _clp_getclsdef(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+2)PUSHNIL();
argno=1;
push_call("getclsdef",base);
//
    line(103);
    line(104);
    _clp_signal_lock(0);
    pop();
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_lock(1);
    pop();
    line(105);
    push_symbol(_st_aclass_ptr());//global
    push_symbol(base+0);//clid
    idxr();
    assign(base+1);//clsdef
    pop();
    line(106);
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_unlock(1);
    pop();
    _clp_signal_unlock(0);
    pop();
    line(107);
    push_symbol(base+1);//clsdef
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classlistall(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,0);
while(stack<base+3)PUSHNIL();
argno=0;
push_call("classlistall",base);
//
    line(111);
    line(113);
    _clp_signal_lock(0);
    pop();
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_lock(1);
    pop();
    line(114);
    push_symbol(_st_aclass_ptr());//global
    _clp_len(1);
    assign(base+2);//clscount
    pop();
    line(115);
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_unlock(1);
    pop();
    _clp_signal_unlock(0);
    pop();
    line(124);
    {
    line(117);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+0);//n
    lab_5_0:
    push_symbol(base+2);//clscount
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_5_2;
        line(118);
        push_symbol(base+0);//n
        _clp_getclsdef(1);
        assign(base+1);//clsdef
        pop();
        line(119);
        push_symbol(base+0);//n
        number(4);
        _clp_str(2);
        push_symbol(base+1);//clsdef
        idxr0(1);
        number(64);
        _clp_padr(2);
        push_symbol(base+1);//clsdef
        idxr0(3);
        number(4);
        _clp_str(2);
        push_symbol(base+1);//clsdef
        idxr0(4);
        number(4);
        _clp_str(2);
        push_symbol(base+1);//clsdef
        idxr0(5);
        _clp_len(1);
        number(4);
        _clp_str(2);
        _clp_qout(5);
        pop();
    lab_5_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+0);//n
    add();
    assign(base+0);//n
    goto lab_5_0;
    lab_5_2:;
    }
    line(125);
    _clp_qout(0);
    pop();
    line(126);
    push(&NIL);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classregister(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+14)PUSHNIL();
argno=2;
push_call("classregister",base);
//
    line(137);
    line(138);
    number(64);
    _clp_array(1);
    assign(base+5);//hash
    pop();
    line(139);
    line(140);
    push(&ZERO);
    assign(base+10);//olen
    pop();
    push(&ZERO);
    assign(base+11);//slen
    pop();
    line(141);
    line(142);
    line(150);
    line(144);
    push_symbol(base+1);//clbaseid
    push(&NIL);
    eqeq();
    cmp_934:;
    if(!flag()) goto if_6_1;
        line(145);
        array(0);
        assign(base+2);//aid
        pop();
    goto if_6_0;
    if_6_1:
    line(146);
    push_symbol(base+1);//clbaseid
    _clp_valtype(1);
    string(L"N");
    eqeq();
    cmp_970:;
    if(!flag()) goto if_6_2;
        line(147);
        push_symbol(base+1);//clbaseid
        array(1);
        assign(base+2);//aid
        pop();
    goto if_6_0;
    if_6_2:
    line(148);
        line(149);
        push_symbol(base+1);//clbaseid
        assign(base+2);//aid
        pop();
    if_6_3:
    if_6_0:;
    line(176);
    line(152);
    push_symbol(base+2);//aid
    _clp_empty(1);
    topnot();
    if(!flag()) goto if_7_1;
        line(157);
        push_symbol(base+2);//aid
        idxr0(1);
        _clp_getclsdef(1);
        idxr0(5);
        assign(base+6);//bhash
        pop();
        line(175);
        {
        line(159);
        push(&ONE);
        int sg=sign();
        push(&ONE);
        assign(base+4);//s
        lab_8_0:
        push_symbol(base+6);//bhash
        _clp_len(1);
        if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_8_2;
            line(174);
            line(160);
            push_symbol(base+6);//bhash
            push_symbol(base+4);//s
            idxr();
            push(&NIL);
            neeq();
            cmp_1095:;
            if(!flag()) goto if_9_1;
                line(161);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(1);
                assign(base+7);//name
                pop();
                line(162);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(2);
                assign(base+8);//value
                pop();
                line(163);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(3);
                assign(base+9);//inherit
                pop();
                line(165);
                push_symbol(base+5);//hash
                push_symbol(base+7);//name
                _clp_hash_index(2);
                assign(base+12);//hashidx
                pop();
                line(166);
                push_symbol(base+7);//name
                push_symbol(base+8);//value
                push_symbol(base+9);//inherit
                array(3);
                push_symbol(base+5);//hash
                push_symbol(base+12);//hashidx
                assign2(idxxl());
                pop();
                line(170);
                line(168);
                push_symbol(base+8);//value
                _clp_valtype(1);
                string(L"N");
                eqeq();
                cmp_1235:;
                if(!flag()) goto if_10_1;
                    line(169);
                    push_symbol(base+10);//olen
                    push(&ONE);
                    add();
                    assign(base+10);//olen
                    pop();
                if_10_1:
                if_10_0:;
                line(173);
                line(171);
                push_symbol(base+11);//slen
                push(&ONE);
                add();
                assign(base+11);//slen
                push_symbol(base+5);//hash
                _clp_len(1);
                mulnum(0.66);
                gt();
                cmp_1268:;
                if(!flag()) goto if_11_1;
                    line(172);
                    push_symbol(base+5);//hash
                    push_symbol(base+5);//hash
                    _clp_len(1);
                    mulnum(2);
                    _clp_hash_rebuild(2);
                    assign(base+5);//hash
                    pop();
                if_11_1:
                if_11_0:;
            if_9_1:
            if_9_0:;
        lab_8_1:
        push(&ONE);
        dup();
        sg=sign();
        push_symbol(base+4);//s
        add();
        assign(base+4);//s
        goto lab_8_0;
        lab_8_2:;
        }
    if_7_1:
    if_7_0:;
    line(207);
    {
    line(178);
    push(&ONE);
    int sg=sign();
    number(2);
    assign(base+3);//i
    lab_12_0:
    push_symbol(base+2);//aid
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_12_2;
        line(180);
        push_symbol(base+2);//aid
        push_symbol(base+3);//i
        idxr();
        _clp_getclsdef(1);
        idxr0(5);
        assign(base+6);//bhash
        pop();
        line(206);
        {
        line(182);
        push(&ONE);
        int sg=sign();
        push(&ONE);
        assign(base+4);//s
        lab_13_0:
        push_symbol(base+6);//bhash
        _clp_len(1);
        if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_13_2;
            line(205);
            line(184);
            push_symbol(base+6);//bhash
            push_symbol(base+4);//s
            idxr();
            push(&NIL);
            neeq();
            cmp_1436:;
            if(!flag()) goto if_14_1;
                line(186);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(1);
                assign(base+7);//name
                pop();
                line(187);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(2);
                assign(base+8);//value
                pop();
                line(188);
                push_symbol(base+6);//bhash
                push_symbol(base+4);//s
                idxr();
                idxr0(3);
                assign(base+9);//inherit
                pop();
                line(190);
                push_symbol(base+5);//hash
                push_symbol(base+7);//name
                _clp_hash_index(2);
                assign(base+12);//hashidx
                pop();
                line(204);
                line(192);
                push_symbol(base+5);//hash
                push_symbol(base+12);//hashidx
                idxr();
                push(&NIL);
                eqeq();
                cmp_1540:;
                if(!flag()) goto if_15_1;
                    line(199);
                    line(195);
                    push_symbol(base+8);//value
                    _clp_valtype(1);
                    string(L"B");
                    eqeq();
                    cmp_1562:;
                    if(!flag()) goto if_16_1;
                        line(196);
                        push_symbol(base+7);//name
                        push_symbol(base+8);//value
                        push_symbol(base+9);//inherit
                        array(3);
                        push_symbol(base+5);//hash
                        push_symbol(base+12);//hashidx
                        assign2(idxxl());
                        pop();
                    goto if_16_0;
                    if_16_1:
                    line(197);
                        line(198);
                        push_symbol(base+7);//name
                        push_symbol(base+10);//olen
                        push(&ONE);
                        add();
                        assign(base+10);//olen
                        push_symbol(base+9);//inherit
                        array(3);
                        push_symbol(base+5);//hash
                        push_symbol(base+12);//hashidx
                        assign2(idxxl());
                        pop();
                    if_16_2:
                    if_16_0:;
                    line(203);
                    line(201);
                    push_symbol(base+11);//slen
                    push(&ONE);
                    add();
                    assign(base+11);//slen
                    push_symbol(base+5);//hash
                    _clp_len(1);
                    mulnum(0.66);
                    gt();
                    cmp_1659:;
                    if(!flag()) goto if_17_1;
                        line(202);
                        push_symbol(base+5);//hash
                        push_symbol(base+5);//hash
                        _clp_len(1);
                        mulnum(2);
                        _clp_hash_rebuild(2);
                        assign(base+5);//hash
                        pop();
                    if_17_1:
                    if_17_0:;
                if_15_1:
                if_15_0:;
            if_14_1:
            if_14_0:;
        lab_13_1:
        push(&ONE);
        dup();
        sg=sign();
        push_symbol(base+4);//s
        add();
        assign(base+4);//s
        goto lab_13_0;
        lab_13_2:;
        }
    lab_12_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+3);//i
    add();
    assign(base+3);//i
    goto lab_12_0;
    lab_12_2:;
    }
    line(209);
    _clp_signal_lock(0);
    pop();
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_lock(1);
    pop();
    line(210);
    push_symbol(_st_aclass_ptr());//global
    push_symbol(base+0);//clname
    _clp_lower(1);
    _clp_str2bin(1);
    push_symbol(base+2);//aid
    push_symbol(base+10);//olen
    push_symbol(base+11);//slen
    push_symbol(base+5);//hash
    array(5);
    _clp_aadd(2);
    pop();
    line(211);
    push_symbol(_st_aclass_ptr());//global
    _clp_len(1);
    assign(base+13);//clid
    pop();
    line(212);
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_unlock(1);
    pop();
    _clp_signal_unlock(0);
    pop();
    line(214);
    push_symbol(base+13);//clid
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classattrib(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+6)PUSHNIL();
argno=2;
push_call("classattrib",base);
//
    line(220);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    assign(base+2);//clsdef
    pop();
    line(221);
    push_symbol(base+1);//name
    _clp_lower(1);
    _clp_str2bin(1);
    assign(base+3);//lname
    pop();
    line(222);
    push_symbol(base+2);//clsdef
    idxr0(5);
    assign(base+4);//hash
    pop();
    line(223);
    push_symbol(base+4);//hash
    push_symbol(base+3);//lname
    _clp_hash_index(2);
    assign(base+5);//hashidx
    pop();
    line(242);
    line(225);
    push_symbol(base+4);//hash
    push_symbol(base+5);//hashidx
    idxr();
    push(&NIL);
    eqeq();
    cmp_2023:;
    if(!flag()) goto if_18_1;
        line(227);
        push_symbol(base+3);//lname
        push_symbol(base+2);//clsdef
        idxr0(3);
        push(&ONE);
        add();
        push_symbol(base+2);//clsdef
        assign2(idxxl0(3));
        push_symbol(base+0);//clid
        array(3);
        push_symbol(base+4);//hash
        push_symbol(base+5);//hashidx
        assign2(idxxl());
        pop();
        line(231);
        line(229);
        push_symbol(base+2);//clsdef
        idxr0(4);
        push(&ONE);
        add();
        push_symbol(base+2);//clsdef
        assign2(idxxl0(4));
        push_symbol(base+4);//hash
        _clp_len(1);
        mulnum(0.66);
        gt();
        cmp_2084:;
        if(!flag()) goto if_19_1;
            line(230);
            push_symbol(base+4);//hash
            push_symbol(base+4);//hash
            _clp_len(1);
            mulnum(2);
            _clp_hash_rebuild(2);
            push_symbol(base+2);//clsdef
            assign2(idxxl0(5));
            pop();
        if_19_1:
        if_19_0:;
    goto if_18_0;
    if_18_1:
    line(233);
        line(241);
        line(238);
        push_symbol(base+4);//hash
        push_symbol(base+5);//hashidx
        idxr();
        idxr0(2);
        _clp_valtype(1);
        string(L"B");
        eqeq();
        cmp_2185:;
        if(!flag()) goto if_20_1;
            line(239);
            push_symbol(base+2);//clsdef
            idxr0(3);
            push(&ONE);
            add();
            push_symbol(base+2);//clsdef
            assign2(idxxl0(3));
            push_symbol(base+4);//hash
            push_symbol(base+5);//hashidx
            idxr();
            assign2(idxxl0(2));
            pop();
            line(240);
            push_symbol(base+0);//clid
            push_symbol(base+4);//hash
            push_symbol(base+5);//hashidx
            idxr();
            assign2(idxxl0(3));
            pop();
        if_20_1:
        if_20_0:;
    if_18_2:
    if_18_0:;
    line(244);
    push(&NIL);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classmethod(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,3);
while(stack<base+10)PUSHNIL();
argno=3;
push_call("classmethod",base);
//
    line(250);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    assign(base+3);//clsdef
    pop();
    line(251);
    push_symbol(base+1);//name
    _clp_lower(1);
    _clp_str2bin(1);
    assign(base+4);//lname
    pop();
    line(252);
    push_symbol(base+3);//clsdef
    idxr0(5);
    assign(base+5);//hash
    pop();
    line(253);
    push_symbol(base+5);//hash
    push_symbol(base+4);//lname
    _clp_hash_index(2);
    assign(base+6);//hashidx
    pop();
    line(254);
    line(283);
    line(256);
    push_symbol(base+5);//hash
    push_symbol(base+6);//hashidx
    idxr();
    push(&NIL);
    eqeq();
    cmp_2403:;
    if(!flag()) goto if_21_1;
        line(258);
        push_symbol(base+4);//lname
        push_symbol(base+2);//methblk
        push_symbol(base+0);//clid
        array(3);
        push_symbol(base+5);//hash
        push_symbol(base+6);//hashidx
        assign2(idxxl());
        pop();
        line(262);
        line(260);
        push_symbol(base+3);//clsdef
        idxr0(4);
        push(&ONE);
        add();
        push_symbol(base+3);//clsdef
        assign2(idxxl0(4));
        push_symbol(base+5);//hash
        _clp_len(1);
        mulnum(0.66);
        gt();
        cmp_2457:;
        if(!flag()) goto if_22_1;
            line(261);
            push_symbol(base+5);//hash
            push_symbol(base+5);//hash
            _clp_len(1);
            mulnum(2);
            _clp_hash_rebuild(2);
            push_symbol(base+3);//clsdef
            assign2(idxxl0(5));
            pop();
        if_22_1:
        if_22_0:;
    goto if_21_0;
    if_21_1:
    line(264);
        line(269);
        push_symbol(base+5);//hash
        push_symbol(base+6);//hashidx
        idxr();
        idxr0(2);
        _clp_valtype(1);
        string(L"N");
        eqeq();
        cmp_2559:;
        assign(base+7);//reindex
        pop();
        line(271);
        push_symbol(base+2);//methblk
        push_symbol(base+5);//hash
        push_symbol(base+6);//hashidx
        idxr();
        assign2(idxxl0(2));
        pop();
        line(272);
        push_symbol(base+0);//clid
        push_symbol(base+5);//hash
        push_symbol(base+6);//hashidx
        idxr();
        assign2(idxxl0(3));
        pop();
        line(282);
        line(274);
        push_symbol(base+7);//reindex
        if(!flag()) goto if_23_1;
            line(275);
            push(&ZERO);
            assign(base+8);//cnt
            pop();
            line(280);
            {
            line(276);
            push(&ONE);
            int sg=sign();
            push(&ONE);
            assign(base+9);//n
            lab_24_0:
            push_symbol(base+5);//hash
            _clp_len(1);
            if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_24_2;
                line(279);
                line(277);
                push_symbol(base+5);//hash
                push_symbol(base+9);//n
                idxr();
                push(&NIL);
                neeq();
                cmp_2657:;
                if(!flag()){
                push(&FALSE);
                }else{
                push_symbol(base+5);//hash
                push_symbol(base+9);//n
                idxr();
                idxr0(2);
                _clp_valtype(1);
                string(L"N");
                eqeq();
                cmp_2682:;
                }
                if(!flag()) goto if_25_1;
                    line(278);
                    push_symbol(base+8);//cnt
                    push(&ONE);
                    add();
                    assign(base+8);//cnt
                    push_symbol(base+5);//hash
                    push_symbol(base+9);//n
                    idxr();
                    assign2(idxxl0(2));
                    pop();
                if_25_1:
                if_25_0:;
            lab_24_1:
            push(&ONE);
            dup();
            sg=sign();
            push_symbol(base+9);//n
            add();
            assign(base+9);//n
            goto lab_24_0;
            lab_24_2:;
            }
            line(281);
            push_symbol(base+8);//cnt
            push_symbol(base+3);//clsdef
            assign2(idxxl0(3));
            pop();
        if_23_1:
        if_23_0:;
    if_21_2:
    if_21_0:;
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classidbyname(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+2)PUSHNIL();
argno=1;
push_call("classidbyname",base);
//
    line(287);
    line(288);
    push_symbol(base+0);//name
    _clp_lower(1);
    _clp_str2bin(1);
    assign(base+0);//name
    pop();
    line(289);
    _clp_signal_lock(0);
    pop();
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_lock(1);
    pop();
    line(290);
    push_symbol(_st_aclass_ptr());//global
    push_symbol_ref(base+0);//name
    block(_blk_classidbyname_0,1);
    _clp_ascan(2);
    assign(base+1);//clid
    pop();
    line(291);
    push_symbol(_st_mutex_ptr());//global
    _clp_thread_mutex_unlock(1);
    pop();
    _clp_signal_unlock(0);
    pop();
    line(292);
    push_symbol(base+1);//clid
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}

static void _blk_classidbyname_0(int argno)
{
VALUE *base=stack-argno;
VALUE *env=blkenv(base);
stack=base+min(argno,2);
while(stack<base+2)PUSHNIL();
argno=2;
push_call("_blk_classidbyname_0",base);
//
    push_symbol(base+1);//c
    idxr0(1);
    push_symbol(env+0);//name
    eqeq();
    cmp_2866:;
//
{*base=*(stack-1);stack=base+1;pop_call();}
}
//=======================================================================
void _clp_classobjectlength(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+1)PUSHNIL();
argno=1;
push_call("classobjectlength",base);
//
    line(297);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(3);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classmethodcount(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+1)PUSHNIL();
argno=1;
push_call("classmethodcount",base);
//
    line(302);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(4);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(3);
    sub();
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classname(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+1)PUSHNIL();
argno=1;
push_call("classname",base);
//
    line(307);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(1);
    _clp_bin2str(1);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classbaseid(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+1)PUSHNIL();
argno=1;
push_call("classbaseid",base);
//
    line(312);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(2);
    _clp_aclone(1);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classattrnames(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+6)PUSHNIL();
argno=2;
push_call("classattrnames",base);
//
    line(317);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(5);
    assign(base+2);//hash
    pop();
    line(318);
    push_symbol(base+0);//clid
    _clp_classobjectlength(1);
    _clp_array(1);
    assign(base+4);//attr
    pop();
    line(323);
    {
    line(319);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+3);//n
    lab_26_0:
    push_symbol(base+2);//hash
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_26_2;
        line(322);
        line(320);
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        push(&NIL);
        neeq();
        cmp_3209:;
        if(!flag()){
        push(&FALSE);
        }else{
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        idxr0(2);
        assign(base+5);//x
        _clp_valtype(1);
        string(L"N");
        eqeq();
        cmp_3238:;
        }
        if(!flag()){
        push(&FALSE);
        }else{
        push_symbol(base+1);//id
        push(&NIL);
        eqeq();
        cmp_3247:;
        if(flag()){
        push(&TRUE);
        }else{
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        idxr0(3);
        push_symbol(base+1);//id
        eqeq();
        cmp_3264:;
        }
        }
        if(!flag()) goto if_27_1;
            line(321);
            push_symbol(base+2);//hash
            push_symbol(base+3);//n
            idxr();
            idxr0(1);
            push_symbol(base+4);//attr
            push_symbol(base+5);//x
            assign2(idxxl());
            pop();
        if_27_1:
        if_27_0:;
    lab_26_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+3);//n
    add();
    assign(base+3);//n
    goto lab_26_0;
    lab_26_2:;
    }
    line(324);
    push_symbol(base+4);//attr
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classmethnames(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+6)PUSHNIL();
argno=2;
push_call("classmethnames",base);
//
    line(329);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(5);
    assign(base+2);//hash
    pop();
    line(330);
    push_symbol(base+0);//clid
    _clp_classmethodcount(1);
    _clp_array(1);
    assign(base+4);//meth
    pop();
    push(&ZERO);
    assign(base+5);//x
    pop();
    line(335);
    {
    line(331);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+3);//n
    lab_28_0:
    push_symbol(base+2);//hash
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_28_2;
        line(334);
        line(332);
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        push(&NIL);
        neeq();
        cmp_3437:;
        if(!flag()){
        push(&FALSE);
        }else{
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        idxr0(2);
        _clp_valtype(1);
        string(L"B");
        eqeq();
        cmp_3462:;
        }
        if(!flag()){
        push(&FALSE);
        }else{
        push_symbol(base+1);//id
        push(&NIL);
        eqeq();
        cmp_3471:;
        if(flag()){
        push(&TRUE);
        }else{
        push_symbol(base+2);//hash
        push_symbol(base+3);//n
        idxr();
        idxr0(3);
        push_symbol(base+1);//id
        eqeq();
        cmp_3488:;
        }
        }
        if(!flag()) goto if_29_1;
            line(333);
            push_symbol(base+2);//hash
            push_symbol(base+3);//n
            idxr();
            idxr0(1);
            _clp_bin2str(1);
            push_symbol(base+4);//meth
            push_symbol(base+5);//x
            push(&ONE);
            add();
            assign(base+5);//x
            assign2(idxxl());
            pop();
        if_29_1:
        if_29_0:;
    lab_28_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+3);//n
    add();
    assign(base+3);//n
    goto lab_28_0;
    lab_28_2:;
    }
    line(336);
    push_symbol(base+4);//meth
    push_symbol(base+5);//x
    _clp_asize(2);
    pop();
    line(337);
    push_symbol(base+4);//meth
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_classinheritstruct(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,1);
while(stack<base+4)PUSHNIL();
argno=1;
push_call("classinheritstruct",base);
//
    line(342);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(5);
    assign(base+1);//hash
    pop();
    array(0);
    assign(base+3);//inherit
    pop();
    line(347);
    {
    line(343);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+2);//n
    lab_30_0:
    push_symbol(base+1);//hash
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_30_2;
        line(346);
        line(344);
        push_symbol(base+1);//hash
        push_symbol(base+2);//n
        idxr();
        push(&NIL);
        neeq();
        cmp_3663:;
        if(!flag()) goto if_31_1;
            line(345);
            push_symbol(base+3);//inherit
            push_symbol(base+1);//hash
            push_symbol(base+2);//n
            idxr();
            idxr0(1);
            _clp_bin2str(1);
            push_symbol(base+1);//hash
            push_symbol(base+2);//n
            idxr();
            idxr0(2);
            _clp_valtype(1);
            string(L"B");
            eqeq();
            cmp_3730:;
            if(flag()){
            string(L"M");
            }else{
            string(L"A");
            }
            push_symbol(base+1);//hash
            push_symbol(base+2);//n
            idxr();
            idxr0(3);
            array(3);
            _clp_aadd(2);
            pop();
        if_31_1:
        if_31_0:;
    lab_30_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+2);//n
    add();
    assign(base+2);//n
    goto lab_30_0;
    lab_30_2:;
    }
    line(349);
    push_symbol(base+3);//inherit
    push(&NIL);
    push(&NIL);
    block(_blk_classinheritstruct_0,0);
    _clp_asort(4);
    pop();
    line(350);
    push_symbol(base+3);//inherit
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}

static void _blk_classinheritstruct_0(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,3);
while(stack<base+3)PUSHNIL();
argno=3;
push_call("_blk_classinheritstruct_0",base);
//
    push_symbol(base+1);//x
    idxr0(3);
    push_symbol(base+2);//y
    idxr0(3);
    lt();
    cmp_3818:;
    if(flag()){
    push(&TRUE);
    }else{
    push_symbol(base+1);//x
    idxr0(3);
    push_symbol(base+2);//y
    idxr0(3);
    eqeq();
    cmp_3835:;
    if(!flag()){
    push(&FALSE);
    }else{
    push_symbol(base+1);//x
    idxr0(1);
    push_symbol(base+2);//y
    idxr0(1);
    lt();
    cmp_3852:;
    }
    }
//
{*base=*(stack-1);stack=base+1;pop_call();}
}
//=======================================================================
void _clp___findslot(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,3);
while(stack<base+7)PUSHNIL();
argno=3;
push_call("__findslot",base);
//
    line(356);
    push_symbol(base+0);//clid
    _clp_getclsdef(1);
    idxr0(5);
    assign(base+3);//hash
    pop();
    line(357);
    push_symbol(base+3);//hash
    push_symbol(base+1);//slotname
    push_symbol(base+2);//hashcode
    _clp_hash_index(3);
    assign(base+4);//hashidx
    pop();
    line(358);
    push_symbol(base+3);//hash
    push_symbol(base+4);//hashidx
    idxr();
    assign(base+5);//item
    pop();
    line(365);
    line(360);
    push_symbol(base+5);//item
    push(&NIL);
    eqeq();
    cmp_3987:;
    if(!flag()) goto if_32_1;
        line(361);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(362);
        push_symbol(base+6);//err
        string(nls_text(L"no exported method"));
        _o_method_description.eval(2);
        pop();
        line(363);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(364);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_32_1:
    if_32_0:;
    line(367);
    push_symbol(base+5);//item
    idxr0(2);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot_c(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,4);
while(stack<base+7)PUSHNIL();
argno=4;
push_call("__findslot_c",base);
//
    line(372);
    line(378);
    line(373);
    push(&ZERO);
    push_symbol(base+2);//classname
    _clp_classidbyname(1);
    assign(base+4);//clid1
    eqeq();
    cmp_4146:;
    if(!flag()) goto if_33_1;
        line(374);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(375);
        push_symbol(base+6);//err
        string(L"'");
        push_symbol(base+2);//classname
        _clp_bin2str(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"not a valid classname"));
        add();
        _o_method_description.eval(2);
        pop();
        line(376);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(377);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_33_1:
    if_33_0:;
    line(380);
    push_symbol(base+4);//clid1
    push_symbol(base+1);//slotname
    push_symbol(base+3);//hashcode
    _clp___findslot(3);
    assign(base+5);//blk
    pop();
    line(387);
    line(382);
    push_symbol(base+5);//blk
    _clp_valtype(1);
    string(L"B");
    eqeq();
    cmp_4340:;
    topnot();
    if(!flag()) goto if_34_1;
        line(383);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(384);
        push_symbol(base+6);//err
        string(nls_text(L"no exported method"));
        _o_method_description.eval(2);
        pop();
        line(385);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(386);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_34_1:
    if_34_0:;
    line(389);
    push_symbol(base+5);//blk
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot_s(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,4);
while(stack<base+11)PUSHNIL();
argno=4;
push_call("__findslot_s",base);
//
    line(395);
    line(396);
    line(403);
    line(398);
    push(&ZERO);
    push_symbol(base+2);//classname
    _clp_classidbyname(1);
    assign(base+4);//clid1
    eqeq();
    cmp_4531:;
    if(!flag()) goto if_35_1;
        line(399);
        _clp_errornew(0);
        assign(base+10);//err
        pop();
        line(400);
        push_symbol(base+10);//err
        string(L"'");
        push_symbol(base+2);//classname
        _clp_bin2str(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"not a valid classname"));
        add();
        _o_method_description.eval(2);
        pop();
        line(401);
        push_symbol(base+10);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(super@");
        add();
        push_symbol(base+2);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(402);
        push_symbol(base+10);//err
        _clp_break(1);
        pop();
    if_35_1:
    if_35_0:;
    line(405);
    push_symbol(base+4);//clid1
    _clp_getclsdef(1);
    idxr0(2);
    assign(base+5);//baseid
    pop();
    line(420);
    {
    line(407);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+6);//i
    lab_36_0:
    push_symbol(base+5);//baseid
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_36_2;
        line(408);
        push_symbol(base+5);//baseid
        push_symbol(base+6);//i
        idxr();
        _clp_getclsdef(1);
        idxr0(5);
        assign(base+7);//hash
        pop();
        line(409);
        push_symbol(base+7);//hash
        push_symbol(base+1);//slotname
        push_symbol(base+3);//hashcode
        _clp_hash_index(3);
        assign(base+8);//hashidx
        pop();
        line(419);
        line(410);
        push_symbol(base+7);//hash
        push_symbol(base+8);//hashidx
        idxr();
        push(&NIL);
        neeq();
        cmp_4792:;
        if(!flag()) goto if_37_1;
            line(411);
            push_symbol(base+7);//hash
            push_symbol(base+8);//hashidx
            idxr();
            idxr0(2);
            assign(base+9);//blk
            pop();
            line(417);
            line(412);
            push_symbol(base+9);//blk
            _clp_valtype(1);
            string(L"B");
            eqeq();
            cmp_4835:;
            topnot();
            if(!flag()) goto if_38_1;
                line(413);
                _clp_errornew(0);
                assign(base+10);//err
                pop();
                line(414);
                push_symbol(base+10);//err
                string(nls_text(L"no exported method"));
                _o_method_description.eval(2);
                pop();
                line(415);
                push_symbol(base+10);//err
                push_symbol(base+0);//clid
                _clp_classname(1);
                string(L":(super@");
                add();
                push_symbol(base+2);//classname
                _clp_bin2str(1);
                add();
                string(L")");
                add();
                push_symbol(base+1);//slotname
                _clp_bin2str(1);
                add();
                _o_method_operation.eval(2);
                pop();
                line(416);
                push_symbol(base+10);//err
                _clp_break(1);
                pop();
            if_38_1:
            if_38_0:;
            line(418);
            push_symbol(base+9);//blk
            {*base=*(stack-1);stack=base+1;pop_call();return;}
        if_37_1:
        if_37_0:;
    lab_36_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+6);//i
    add();
    assign(base+6);//i
    goto lab_36_0;
    lab_36_2:;
    }
    line(422);
    _clp_errornew(0);
    assign(base+10);//err
    pop();
    line(423);
    push_symbol(base+10);//err
    string(nls_text(L"no exported method"));
    _o_method_description.eval(2);
    pop();
    line(424);
    push_symbol(base+10);//err
    push_symbol(base+0);//clid
    _clp_classname(1);
    string(L":(super@");
    add();
    push_symbol(base+2);//classname
    _clp_bin2str(1);
    add();
    string(L")");
    add();
    push_symbol(base+1);//slotname
    _clp_bin2str(1);
    add();
    _o_method_operation.eval(2);
    pop();
    line(425);
    push_symbol(base+10);//err
    _clp_break(1);
    pop();
    line(427);
    push(&NIL);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot_p(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,5);
while(stack<base+9)PUSHNIL();
argno=5;
push_call("__findslot_p",base);
//
    line(433);
    line(440);
    line(435);
    push(&ZERO);
    push_symbol(base+3);//classname
    _clp_classidbyname(1);
    assign(base+5);//clid0
    eqeq();
    cmp_5130:;
    if(!flag()) goto if_39_1;
        line(436);
        _clp_errornew(0);
        assign(base+8);//err
        pop();
        line(437);
        push_symbol(base+8);//err
        string(L"'");
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"not a valid classname"));
        add();
        _o_method_description.eval(2);
        pop();
        line(438);
        push_symbol(base+8);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(439);
        push_symbol(base+8);//err
        _clp_break(1);
        pop();
    if_39_1:
    if_39_0:;
    line(447);
    line(442);
    push(&ZERO);
    push_symbol(base+2);//prntname
    _clp_classidbyname(1);
    assign(base+6);//clid1
    eqeq();
    cmp_5300:;
    if(!flag()) goto if_40_1;
        line(443);
        _clp_errornew(0);
        assign(base+8);//err
        pop();
        line(444);
        push_symbol(base+8);//err
        string(L"'");
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"not a valid classname"));
        add();
        _o_method_description.eval(2);
        pop();
        line(445);
        push_symbol(base+8);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(446);
        push_symbol(base+8);//err
        _clp_break(1);
        pop();
    if_40_1:
    if_40_0:;
    line(454);
    line(449);
    push(&ZERO);
    push_symbol(base+5);//clid0
    _clp_getclsdef(1);
    idxr0(2);
    push_symbol(base+6);//clid1
    _clp_ascan(2);
    eqeq();
    cmp_5470:;
    if(!flag()) goto if_41_1;
        line(450);
        _clp_errornew(0);
        assign(base+8);//err
        pop();
        line(451);
        push_symbol(base+8);//err
        string(L"'");
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"is not parent of"));
        add();
        string(L" '");
        add();
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L"'");
        add();
        _o_method_description.eval(2);
        pop();
        line(452);
        push_symbol(base+8);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(453);
        push_symbol(base+8);//err
        _clp_break(1);
        pop();
    if_41_1:
    if_41_0:;
    line(456);
    push_symbol(base+6);//clid1
    push_symbol(base+1);//slotname
    push_symbol(base+4);//hashcode
    _clp___findslot(3);
    assign(base+7);//blk
    pop();
    line(463);
    line(458);
    push_symbol(base+7);//blk
    _clp_valtype(1);
    string(L"B");
    eqeq();
    cmp_5712:;
    topnot();
    if(!flag()) goto if_42_1;
        line(459);
        _clp_errornew(0);
        assign(base+8);//err
        pop();
        line(460);
        push_symbol(base+8);//err
        string(nls_text(L"no exported method"));
        _o_method_description.eval(2);
        pop();
        line(461);
        push_symbol(base+8);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//prntname
        _clp_bin2str(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//classname
        _clp_bin2str(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(462);
        push_symbol(base+8);//err
        _clp_break(1);
        pop();
    if_42_1:
    if_42_0:;
    line(465);
    push_symbol(base+7);//blk
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp_getmethod(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+2)PUSHNIL();
argno=2;
push_call("getmethod",base);
//
    line(470);
    push_symbol(base+0);//clid
    push_symbol(base+1);//name
    _clp_lower(1);
    _clp_str2bin(1);
    _clp___findslot(2);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
static void _clp_isderivedfrom(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,2);
while(stack<base+4)PUSHNIL();
argno=2;
push_call("isderivedfrom",base);
//
    line(477);
    line(487);
    line(478);
    push_symbol(base+1);//clb
    push_symbol(base+0);//cld
    eqeq();
    cmp_5946:;
    if(!flag()) goto if_43_1;
        line(479);
        push(&TRUE);
        {*base=*(stack-1);stack=base+1;pop_call();return;}
    goto if_43_0;
    if_43_1:
    line(480);
        line(481);
        push_symbol(base+0);//cld
        _clp_classbaseid(1);
        assign(base+2);//baseid
        pop();
        line(486);
        {
        line(482);
        push(&ONE);
        int sg=sign();
        push(&ONE);
        assign(base+3);//n
        lab_44_0:
        push_symbol(base+2);//baseid
        _clp_len(1);
        if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_44_2;
            line(485);
            line(483);
            push_symbol(base+2);//baseid
            push_symbol(base+3);//n
            idxr();
            push_symbol(base+1);//clb
            _clp_isderivedfrom(2);
            if(!flag()) goto if_45_1;
                line(484);
                push(&TRUE);
                {*base=*(stack-1);stack=base+1;pop_call();return;}
            if_45_1:
            if_45_0:;
        lab_44_1:
        push(&ONE);
        dup();
        sg=sign();
        push_symbol(base+3);//n
        add();
        assign(base+3);//n
        goto lab_44_0;
        lab_44_2:;
        }
    if_43_2:
    if_43_0:;
    line(488);
    push(&FALSE);
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot3_c(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,4);
while(stack<base+6)PUSHNIL();
argno=4;
push_call("__findslot3_c",base);
//
    line(493);
    line(502);
    line(497);
    push_symbol(base+0);//clid
    push_symbol(base+2);//clid1
    _clp_isderivedfrom(2);
    topnot();
    if(!flag()) goto if_46_1;
        line(498);
        _clp_errornew(0);
        assign(base+5);//err
        pop();
        line(499);
        push_symbol(base+5);//err
        string(nls_text(L"prohibited method cast"));
        _o_method_description.eval(2);
        pop();
        line(500);
        push_symbol(base+5);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(501);
        push_symbol(base+5);//err
        _clp_break(1);
        pop();
    if_46_1:
    if_46_0:;
    line(504);
    push_symbol(base+2);//clid1
    push_symbol(base+1);//slotname
    push_symbol(base+3);//hashcode
    _clp___findslot(3);
    assign(base+4);//blk
    pop();
    line(511);
    line(506);
    push_symbol(base+4);//blk
    _clp_valtype(1);
    string(L"B");
    eqeq();
    cmp_6288:;
    topnot();
    if(!flag()) goto if_47_1;
        line(507);
        _clp_errornew(0);
        assign(base+5);//err
        pop();
        line(508);
        push_symbol(base+5);//err
        string(nls_text(L"prohibited attribute cast"));
        _o_method_description.eval(2);
        pop();
        line(509);
        push_symbol(base+5);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(510);
        push_symbol(base+5);//err
        _clp_break(1);
        pop();
    if_47_1:
    if_47_0:;
    line(513);
    push_symbol(base+4);//blk
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot3_s(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,4);
while(stack<base+10)PUSHNIL();
argno=4;
push_call("__findslot3_s",base);
//
    line(518);
    line(519);
    line(528);
    line(523);
    push_symbol(base+0);//clid
    push_symbol(base+2);//clid1
    _clp_isderivedfrom(2);
    topnot();
    if(!flag()) goto if_48_1;
        line(524);
        _clp_errornew(0);
        assign(base+9);//err
        pop();
        line(525);
        push_symbol(base+9);//err
        string(nls_text(L"prohibited method cast"));
        _o_method_description.eval(2);
        pop();
        line(526);
        push_symbol(base+9);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(super@");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(527);
        push_symbol(base+9);//err
        _clp_break(1);
        pop();
    if_48_1:
    if_48_0:;
    line(530);
    push_symbol(base+2);//clid1
    _clp_getclsdef(1);
    idxr0(2);
    assign(base+4);//baseid
    pop();
    line(545);
    {
    line(532);
    push(&ONE);
    int sg=sign();
    push(&ONE);
    assign(base+5);//i
    lab_49_0:
    push_symbol(base+4);//baseid
    _clp_len(1);
    if( ((sg>=0)&&greaterthan()) || ((sg<0)&&lessthan())) goto lab_49_2;
        line(533);
        push_symbol(base+4);//baseid
        push_symbol(base+5);//i
        idxr();
        _clp_getclsdef(1);
        idxr0(5);
        assign(base+6);//hash
        pop();
        line(534);
        push_symbol(base+6);//hash
        push_symbol(base+1);//slotname
        push_symbol(base+3);//hashcode
        _clp_hash_index(3);
        assign(base+7);//hashidx
        pop();
        line(544);
        line(535);
        push_symbol(base+6);//hash
        push_symbol(base+7);//hashidx
        idxr();
        push(&NIL);
        neeq();
        cmp_6713:;
        if(!flag()) goto if_50_1;
            line(536);
            push_symbol(base+6);//hash
            push_symbol(base+7);//hashidx
            idxr();
            idxr0(2);
            assign(base+8);//blk
            pop();
            line(542);
            line(537);
            push_symbol(base+8);//blk
            _clp_valtype(1);
            string(L"B");
            eqeq();
            cmp_6756:;
            topnot();
            if(!flag()) goto if_51_1;
                line(538);
                _clp_errornew(0);
                assign(base+9);//err
                pop();
                line(539);
                push_symbol(base+9);//err
                string(nls_text(L"prohibited attribute cast"));
                _o_method_description.eval(2);
                pop();
                line(540);
                push_symbol(base+9);//err
                push_symbol(base+0);//clid
                _clp_classname(1);
                string(L":(super@");
                add();
                push_symbol(base+2);//clid1
                _clp_classname(1);
                add();
                string(L")");
                add();
                push_symbol(base+1);//slotname
                _clp_bin2str(1);
                add();
                _o_method_operation.eval(2);
                pop();
                line(541);
                push_symbol(base+9);//err
                _clp_break(1);
                pop();
            if_51_1:
            if_51_0:;
            line(543);
            push_symbol(base+8);//blk
            {*base=*(stack-1);stack=base+1;pop_call();return;}
        if_50_1:
        if_50_0:;
    lab_49_1:
    push(&ONE);
    dup();
    sg=sign();
    push_symbol(base+5);//i
    add();
    assign(base+5);//i
    goto lab_49_0;
    lab_49_2:;
    }
    line(547);
    _clp_errornew(0);
    assign(base+9);//err
    pop();
    line(548);
    push_symbol(base+9);//err
    string(nls_text(L"no exported method"));
    _o_method_description.eval(2);
    pop();
    line(549);
    push_symbol(base+9);//err
    push_symbol(base+0);//clid
    _clp_classname(1);
    string(L":(super@");
    add();
    push_symbol(base+2);//clid1
    _clp_classname(1);
    add();
    string(L")");
    add();
    push_symbol(base+1);//slotname
    _clp_bin2str(1);
    add();
    _o_method_operation.eval(2);
    pop();
    line(550);
    push_symbol(base+9);//err
    _clp_break(1);
    pop();
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================
void _clp___findslot3_p(int argno)
{
VALUE *base=stack-argno;
stack=base+min(argno,5);
while(stack<base+7)PUSHNIL();
argno=5;
push_call("__findslot3_p",base);
//
    line(556);
    line(565);
    line(560);
    push_symbol(base+0);//clid
    push_symbol(base+3);//clid0
    _clp_isderivedfrom(2);
    topnot();
    if(!flag()) goto if_52_1;
        line(561);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(562);
        push_symbol(base+6);//err
        string(nls_text(L"prohibited method cast"));
        _o_method_description.eval(2);
        pop();
        line(563);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//clid0
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(564);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_52_1:
    if_52_0:;
    line(572);
    line(567);
    push(&ZERO);
    push_symbol(base+3);//clid0
    _clp_getclsdef(1);
    idxr0(2);
    push_symbol(base+2);//clid1
    _clp_ascan(2);
    eqeq();
    cmp_7183:;
    if(!flag()) goto if_53_1;
        line(568);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(569);
        push_symbol(base+6);//err
        string(L"'");
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L"' ");
        add();
        string(nls_text(L"is not parent of"));
        add();
        string(L" '");
        add();
        push_symbol(base+3);//clid0
        _clp_classname(1);
        add();
        string(L"'");
        add();
        _o_method_description.eval(2);
        pop();
        line(570);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//clid0
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(571);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_53_1:
    if_53_0:;
    line(574);
    push_symbol(base+2);//clid1
    push_symbol(base+1);//slotname
    push_symbol(base+4);//hashcode
    _clp___findslot(3);
    assign(base+5);//blk
    pop();
    line(581);
    line(576);
    push_symbol(base+5);//blk
    _clp_valtype(1);
    string(L"B");
    eqeq();
    cmp_7425:;
    topnot();
    if(!flag()) goto if_54_1;
        line(577);
        _clp_errornew(0);
        assign(base+6);//err
        pop();
        line(578);
        push_symbol(base+6);//err
        string(nls_text(L"prohibited attribute cast"));
        _o_method_description.eval(2);
        pop();
        line(579);
        push_symbol(base+6);//err
        push_symbol(base+0);//clid
        _clp_classname(1);
        string(L":(");
        add();
        push_symbol(base+2);//clid1
        _clp_classname(1);
        add();
        string(L"@");
        add();
        push_symbol(base+3);//clid0
        _clp_classname(1);
        add();
        string(L")");
        add();
        push_symbol(base+1);//slotname
        _clp_bin2str(1);
        add();
        _o_method_operation.eval(2);
        pop();
        line(580);
        push_symbol(base+6);//err
        _clp_break(1);
        pop();
    if_54_1:
    if_54_0:;
    line(583);
    push_symbol(base+5);//blk
    {*base=*(stack-1);stack=base+1;pop_call();return;}
//
stack=base;
push(&NIL);
pop_call();
}
//=======================================================================

