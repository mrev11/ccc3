
James K.Louden wrote:

> As has been repeated several times in this thread, the act of updating
> a SQLite database while a SELECT is being processed interferes with the
> SELECT unless WAL mode is used.  

But as you can see in line 6, WAL mode is used.


Richard Hipp wrote:

> Compare to 101 lines of Ruby and 430 lines of C++. 

You have counted the lines in my script so you  probably saw the comments at the bottom of it. In these comments I described possibilities how to avoid the bad result. So I do not  need any advice for that. Additionally I do not have any SQLite3 application containing the disputed design pattern. As I have written I am only an interface writer. I write interface to CCC  for several databases: Oracle, Postgres, MySQL, DB2 and also SQLite3. From point of view of my work it makes no difference if SQLite3 is faulty or not.

There is a very important additional possibility to avoid the error (not mentioned in the script). If you put a comment sign (#) at the beginning of the line 28 and leave out creating that index, the result will be like expected. Imagine a program, which contains the disputed design pattern but not the index. The program operates without any error. Developer and user are contented. But once somebody gets the idea to optimize, adds a new index to the database, and some of the programs operating on that database unexpectedly become faulty.   


In the end I have questions:

The Ruby script gives the expected result (at least expected by me) if I use the 3.7.9 version of SQLite3 library. Is it a pure accident which happened in contrary to the fact  that SQLite3 does not support the "bad design pattern"?  

If you decided not to support such basic design pattern, why does not give the update statement an error code instead of running blindly to an endless loop and ruining the data?


