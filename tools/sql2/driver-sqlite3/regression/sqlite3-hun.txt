
James K.Louden wrote:

> As has been repeated several times in this thread, the act of updating
> a Sq Lite database while a SELECT is being processed interferes with the
> SELECT unless WAL mode is used.  

De ahogy látod (látjátok), a program WAL módot használ.


Richard Kipp wrote:

> Compare to 101 lines of Ruby and 430 lines of C++. 

Megszámoltad a sorokat a scriptemben, ezért valószínűleg láttad a kommenteket az alján. Ezekben a kommentekben leírtam több lehetőséget, hogyan lehet a hibás eredményt elkerülni. Ezért nincs szükségem erre vonatkozó tanácsokra. Ezenkívül SQLite3 alkalmazásaim sincsenek, amik tartalmaznák a vitatott tervezési mintát. Ahogy korábban írtam, én csak egy interfész író vagyok. Interfészt írok a CCC-hez különböző adatbázisokhoz: Oracle, Postgres, MySQL, DB2-höz és SQLite3-hoz is. A munkám szempontjából mindegy, hogy az SQLite3 hibásan működik vagy nem.

Van egy további nagyon fontos lehetőség a hiba elkerülésére (ami nincs említve a scriptben). Ha teszel egy komment jelet (#) a 28. sor elejére, és így kihagyod az ottani index létrehozását, akkor az eredmény az elvárt lesz. Képzelj el egy programot, ami tartalmazza a vitatott tervezési mintát, de az indexet nem. A program hibátlanul működik. Fejlesztő és felhasználó elégedett. Egyszer azonban valakinek eszébe jut, hogy optimalizálni akar, és hozzád az adatbázishoz egy indexet, amire az adatbázison működő programok némelyike váratlanul hibássá válik.


Végül van néhány kérdésem:

A Ruby script az elvárt eredményt adja (legalábbis az általam elvártat), ha az SQLite3 könyvtár 3.7.9 változatát használom. Ez vajon csak egy véletlen, ami annak ellenére történt, hogy az SQLite3 nem támogatja a "rossz tervezési mintát"?

Ha úgy döntöttél, hogy egy ilyen alapvető tervezési minta ne legyen támogatva, akkor miért nem ad az update utasítás hibakódot ahelyett, hogy vakon beleszalad egy végtelen ciklusba, és elrontja az adatokat?








