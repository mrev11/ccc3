2009.09.27

  Az sqlconnection objektum az (új) __isolationlevel__ attribútumban 
  tárolja az utoljára beállított (session) levelt, amit most le lehet 
  kérdezni az sqlisolationlevel metódussal.

  oracle.tableentity:create-ban:
    A table create előtt átvált READ_COMMITTED isolation levelre,
    mert az Oracle table create nem működik SERIALIZABLE módban.
    A table create után visszavált az eredeti isolation levelre.

  tableentity:create-ban:
    Oraclenél előbb a default utána a not null,
    Postgresnél nem számít a sorrend.

  ocierror-ban:
    A hibakód és a hibaszöveg minden esetben kiolvasva,
    a description attribútumba mindig a kiolvasott szöveg kerül.

    Kezelve az "ORA-00604: error occurred at recursive SQL level 1" eset.
    Ilyenkor a hibaüzenet kétsoros,
    és a második sor tartalmazza a tényleges hibát.
    Elő lehet-e azt szedni máshonnan, mint a szövegből?
    Van-e 2-nél is több soros hiba?
    Az eddig látott esetekben a 604-es hibát egy
    "ORA-08177: can't serialize access for this transaction" hiba követi,
    ezt kell előszedni a második sorból, hogy kezelhető legyen.

  A blobok (memók) beírásakor a visszaolvasó select SERIALIZABLE módban néha 
  "ORA-01403: no data found" hibát ad. Ilyenkor is segít az egész tranzakció 
  ismétlése. Ezért a memowrite kicseréli a 1403-as hibát 8177-re.

  Megj: 
    Az Oracle serializable módban akkor is képes serial errort adni, 
    ha egyedül fut egy program, azaz biztosan nincs konkurrencia.
    Tapasztalat szerint ilyenkor a megismételt tranzakció lefut.
    
  sqlerror objektumok:  
    Változott az sqldeadlockerror leszármazása, most két baseclass-a van,
    sqllockerror, sqlserialerror. Tehát "recover e <sqlserialerror>" most 
    a deadlockokat is elkapja.

    A sqllockerror, sqlserialerror, sqldeadlockerror objektumok
    canrerty mezeje .t.-re inicializálódik.


  Mindkét könyvtárban a connection/statement handlerek nyilvántartása
  szinkronizálva lett. Ugyanazon a connection-on keresztül egyszerre csak 
  egy szál dolgozhat (így értelmes), de külön connection-okon keresztül
  a szálak egyszerre is dolgozhatnak.


2009.02.19
  sqlliteral kibővítve az array típusra:
    {a,b,c} -> (a,b,c)
  ahol a tömbelemek az elemi típusok konverziós szabályai szerint
  konvertálódnak. Pl. az 
    'x' in :1
  feltételnél az :1 helyére behelyettesíthető egy array {'x','y','z'}.

2008.03.31
  Koncepció váltás: Az insert azokat a mezőket küldi a szervernek,
  amikre az isnull .f.-et ad. Korábban azokat küldte, amikre isdirty
  .t. volt.

2007.10.29
  dereferencing type-punned pointer will break strict-aliasing rules
  E warningok kitisztítása: (void**)&var -> (void**)(void*)&var.

2007.07.05
  Az insert-nél a null értékű mezőket kihagyjuk.
  Korábban a nem dirty mezőket írtuk ki, azonban egy
  column:='' értékadás után a mező null, de nem dirty.

  Visszavéve a módosítás, ami a primary key mezőket automatikusan 
  not null-ra állította.
  
  sqlbind-ben TRANSFORM_NULL_EQUALS
  Ha az ilyen kifejezésekben mint "expr=:1", a placeholder helyére 
  null kerül, akkor az "expr=null"-t cseréli "expr is null"-ra.
  Tipikusan akkor lesz null a placeholder, amikor egy üres stringet,
  vagy üres dátumot az sqlliteral null-ra cserél.

2007.06.01
  A Postgres driverben saját escape függvény, ami
  E'proba \\ooo \\ooo szerencse'0 alakra hozza a bytea típust.
  Hosszú ideje nem tudnak megállapodni a formátumban.
  A régebbi szerverek nem fogadják el az E prefixet (8.0.x-ig).
  Az újabb szerverek E prefixszel szeretik a stringet (8.1.x-től).
  Állítólag az is szerverfüggő, hogy \ vagy \\ kell-e.

  Az Oracle driverben a tab:instance nem jól inicializálta 
  az új rowentity bufferét.

  A tds primkey-ben felsorolt oszlopok notnull attribútuma 
  automatikusan .t.-re van állítva.

  A mkblk_c null-ra állítja a mezőt, ha annak új értéke empty
  (hasonlóan  az empty dátum értékekhez).  Ha ez nem így volna, 
  akkor az sqlvalue-ban a trimelésekor szembesülnénk azzal, 
  hogy az Oracleben nem létezik üres string, pl. '' vagy trim(' ')
  egyaránt a null-t jelentik. Ha a trimelést hagyjuk el (sqlvalue-ban), 
  akkor az oszlopleképezéstől függ az érték, pl. nem lesznek egyenlők 
  különböző hosszú mezőből kiírt értékek (nem lehet rá keresni).
  Lehetne még a ''-t ' '-vel helyettesíteni kiíráskor (zagyvaság).

  A nem használt mkblk_x törölve.
  Megjegyzés: A mkblk_x csak abban különbözött mkblk_c-től, hogy nem 
  csinált str2bin/bin2str transzformációt a binárisan tárolt adatra.
  Postgresben azonban a char/varchar mezők nem tudnak bináris adatot
  tartalmazni (csak a bytea). A bytea mezőkkel viszont nem lehet
  normálisan dolgozni a psql-ben. Ezért az X típusú leképezés ejtve.

2006.09.15
  Áttérés a class szintaktikára.

  sql2.*.slqvalue() kiegészült a null értékek vizsgálatával,
  ezzel insert/update rávehető, hogy null-okat küldjön a szervernek,
  ha egy mezőre be van állítva c:setdirty(row,.t.) és c:setnull(row,.t.).
  Megjegyzés, null érték lekérdezése: c:isnull(row).
  
  con:sqlexec("select ... for update") 
  támogatása, korábban ez Oracleben nem működött, 
  noha van értelme, mert így lockolni lehet a rekordokat 
  (amiket nem kérdezünk le, legalábbis nem ezzel a selecttel).

  Dokumentáció felülvizsgálva.

2005.08.17
  dirtyflag manipuláció 
        col:isdirty(row)
        col:setdirty(row,flag) //egy oszlop
        row:setdirty(flag)     //összes oszlop
        tab:setdirty(row,flag) //összes oszlop

  nullflag manipuláció  
        col:isnull(row)
        col:setnull(row,flag)  //egy oszlop
        row:setnull(flag)      //összes oszlop
        tab:setnull(row,flag)  //összes oszlop

  rowcount 
        con:sqlexec return értéke insert/update/delete 
        utasítások esetén az érintett rekordok száma 
        (más utasításoknál 0, korábban NIL volt).
    
  sqlrowcounterror
        Új kivétel, row:update és row:delete dobja,
        ha rowcount!=1, ui. ez azt mutatja, hogy baj van a
        primary key egyediségével, amin az egész rendszer alapszik.


