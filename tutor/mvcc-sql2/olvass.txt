
A demó mutatja, hogy a három adatbáziskezelő ISOL_SERIALIZABLE módban 
hasonlóan kezeli a konkurens tranzakciókat. 

Megjegyzés: SQLite3-ban nincs is más mód. Az SQLite-ot WAL-lal használjuk.

1)  El kell indítani c1-et. 
    Ez a konto.proba tábla egyetlen rekordját 1 másodpercenként módosítja.

2)  Egy másik terminálban el kell indítani c2-t. 
    Ez 3 másodpecenként olvassa az előbbi rekordot, és mutatja, hogy mit lát.
    
    Ha space-t nyomunk neki, akkor új olvasó tranzakciót kezd.
    Ha x-et nyomunk neki, akkor megpróbál beleírni a rekordba (író tranzakció).

Akkor most az SQLite is egy többfelhasználós MVCC (Multi Version Concurrency 
Control) adatbáziskezelő? Nem teljesen. Az igazi MVCC adatbáziskezelők el tudják 
különíteni a tranzakciókat, ha azok időben vagy térben diszjunktak, deadlockot 
detektálnak, stb. Az SQLite3 tudása annyi, hogy felismeri az időben átfedő 
író tranzakciókat, és az ilyeneket nem engedi befejezni. Mindenesetre látszik, 
hogy a WAL algoritmusból lényegében már adódik az MVCC legfontosabb eleme.  

